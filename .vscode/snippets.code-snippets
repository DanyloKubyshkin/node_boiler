{
	"Domain index file": {
		"prefix": "nbp-d-index",
		"body": [
			"const { routes } = require('./api');",
			"",
			"const defineRoutes = (expressRouter) => {",
			"  expressRouter.use('/${1:route}', routes());",
			"};",
			"",
			"module.exports = defineRoutes;"
		],
		"description": "Nodejs boilerplate domain's index file"
	},
	"Domain API CRUD Routes": {
		"prefix": "nbp-d-api",
		"body": [
			"const express = require('express');",
			"const logger = require('../../libraries/log/logger');",
			"const { AppError } = require('../../libraries/error-handling/AppError');",
			"",
			"const {",
			"  create,",
			"  search,",
			"  getById,",
			"  updateById,",
			"  deleteById,",
			"} = require('./service');",
			"",
			"const { createSchema, updateSchema, idSchema } = require('./request');",
			"const { validateRequest } = require('../../middlewares/request-validate');",
			"const { logRequest } = require('../../middlewares/log');",
			"",
			"const model = '${1:Product}';",
			"",
			"// CRUD for entity",
			"const routes = () => {",
			"  const router = express.Router();",
			"  logger.info(`Setting up routes for ${model}`);",
			"",
			"  router.get('/', logRequest({}), async (req, res, next) => {",
			"    try {",
			"      // TODO: Add pagination and filtering",
			"      const items = await search(req.query);",
			"      res.json(items);",
			"    } catch (error) {",
			"      next(error);",
			"    }",
			"  });",
			"",
			"  router.post(",
			"    '/',",
			"    logRequest({}),",
			"    validateRequest({ schema: createSchema }),",
			"    async (req, res, next) => {",
			"      try {",
			"        const item = await create(req.body);",
			"        res.status(201).json(item);",
			"      } catch (error) {",
			"        next(error);",
			"      }",
			"    }",
			"  );",
			"",
			"  router.get(",
			"    '/:id',",
			"    logRequest({}),",
			"    validateRequest({ schema: idSchema, isParam: true }),",
			"    async (req, res, next) => {",
			"      try {",
			"        const item = await getById(req.params.id);",
			"        if (!item) {",
			"          throw new AppError(`${model} not found`, `${model} not found`, 404);",
			"        }",
			"        res.status(200).json(item);",
			"      } catch (error) {",
			"        next(error);",
			"      }",
			"    }",
			"  );",
			"",
			"  router.put(",
			"    '/:id',",
			"    logRequest({}),",
			"    validateRequest({ schema: idSchema, isParam: true }),",
			"    validateRequest({ schema: updateSchema }),",
			"    async (req, res, next) => {",
			"      try {",
			"        const item = await updateById(req.params.id, req.body);",
			"        if (!item) {",
			"          throw new AppError(`${model} not found`, `${model} not found`, 404);",
			"        }",
			"        res.status(200).json(item);",
			"      } catch (error) {",
			"        next(error);",
			"      }",
			"    }",
			"  );",
			"",
			"  router.delete(",
			"    '/:id',",
			"    logRequest({}),",
			"    validateRequest({ schema: idSchema, isParam: true }),",
			"    async (req, res, next) => {",
			"      try {",
			"        await deleteById(req.params.id);",
			"        res.status(204).json({ message: `${model} is deleted` });",
			"      } catch (error) {",
			"        next(error);",
			"      }",
			"    }",
			"  );",
			"",
			"  return router;",
			"};",
			"",
			"module.exports = { routes };"
		],
		"description": "CRUD routes for a model"
	},
	"Domain CRUD Service": {
		"prefix": "nbp-d-service",
		"body": [
			"const logger = require('../../libraries/log/logger');",
			"",
			"const Model = require('./schema');",
			"const { AppError } = require('../../libraries/error-handling/AppError');",
			"",
			"const model = '${1:product}';",
			"",
			"const create = async (data) => {",
			"  try {",
			"    const item = new Model(data);",
			"    const saved = await item.save();",
			"    logger.info(`create(): ${model} created`, {",
			"      id: saved._id,",
			"    });",
			"    return saved;",
			"  } catch (error) {",
			"    logger.error(`create(): Failed to create ${model}`, error);",
			"    throw new AppError(`Failed to create ${model}`, error.message);",
			"  }",
			"};",
			"",
			"const search = async (query) => {",
			"  try {",
			"    const { keyword } = query ?? {};",
			"    const filter = {};",
			"    if (keyword) {",
			"      filter.$or = [",
			"        { name: { $regex: keyword, $options: 'i' } },",
			"        { description: { $regex: keyword, $options: 'i' } },",
			"      ];",
			"    }",
			"    const items = await Model.find(filter);",
			"    logger.info('search(): filter and count', {",
			"      filter,",
			"      count: items.length,",
			"    });",
			"    return items;",
			"  } catch (error) {",
			"    logger.error(`search(): Failed to search ${model}`, error);",
			"    throw new AppError(`Failed to search ${model}`, error.message, 400);",
			"  }",
			"};",
			"",
			"const getById = async (id) => {",
			"  try {",
			"    const item = await Model.findById(id);",
			"    logger.info(`getById(): ${model} fetched`, { id });",
			"    return item;",
			"  } catch (error) {",
			"    logger.error(`getById(): Failed to get ${model}`, error);",
			"    throw new AppError(`Failed to get ${model}`, error.message);",
			"  }",
			"};",
			"",
			"const updateById = async (id, data) => {",
			"  try {",
			"    const item = await Model.findByIdAndUpdate(id, data, { new: true });",
			"    logger.info(`updateById(): ${model} updated`, { id });",
			"    return item;",
			"  } catch (error) {",
			"    logger.error(`updateById(): Failed to update ${model}`, error);",
			"    throw new AppError(`Failed to update ${model}`, error.message);",
			"  }",
			"};",
			"",
			"const deleteById = async (id) => {",
			"  try {",
			"    await Model.findByIdAndDelete(id);",
			"    logger.info(`deleteById(): ${model} deleted`, { id });",
			"    return true;",
			"  } catch (error) {",
			"    logger.error(`deleteById(): Failed to delete ${model}`, error);",
			"    throw new AppError(`Failed to delete ${model}`, error.message);",
			"  }",
			"};",
			"",
			"module.exports = {",
			"  create,",
			"  search,",
			"  getById,",
			"  updateById,",
			"  deleteById,",
			"};"
		],
		"description": "CRUD service for a model"
	},
	"Mongoose Schema": {
		"prefix": "nbp-mongoose-schema",
		"body": [
			"const mongoose = require('mongoose');",
			"const { baseSchema } = require('../../libraries/db/base-schema');",
			"",
			"const schema = new mongoose.Schema({",
			"  name: { type: String, required: true },",
			"  // other properties",
			"});",
			"schema.add(baseSchema);",
			"",
			"module.exports = mongoose.model('${1:Model}', schema);"
		],
		"description": "Mongoose schema"
	},
	"Joi Validation Schemas": {
		"prefix": "nbp-joi-schemas",
		"body": [
			"const Joi = require('joi');",
			"const mongoose = require('mongoose');",
			"",
			"const createSchema = Joi.object().keys({",
			"  name: Joi.string().required(),",
			"  // other properties",
			"});",
			"",
			"const updateSchema = Joi.object().keys({",
			"  name: Joi.string(),",
			"  // other properties",
			"});",
			"",
			"const idSchema = Joi.object().keys({",
			"  id: Joi.string()",
			"    .custom((value, helpers) => {",
			"      if (!mongoose.Types.ObjectId.isValid(value)) {",
			"        return helpers.error('any.invalid');",
			"      }",
			"      return value;",
			"    }, 'ObjectId validation')",
			"    .required(),",
			"});",
			"",
			"module.exports = { createSchema, updateSchema, idSchema };"
		],
		"description": "Joi validation schemas"
	}
}
